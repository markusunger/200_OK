#!/usr/bin/node

// this tool will be run by a cronjob every 24 hrs, deleting all APIs and their
// associated data when they don't meet the cutoff date (current date - 7 days)
// for their creation

// deletion is not done in transactions (since they're only supported with replica
// sets or sharded clusters), so logging will provide the only way to see if
// something went wrong and the db might be inconsistent

/* eslint-disable no-console */

const store = require('../db/mongo');
const { apiExpirationDays } = require('../lib/config');

(async function cleanup() {
  // first, register handlers for unexpected crashes
  process.on('uncaughtException', async (error) => {
    console.error('Unexpected shutdown!');
    console.error(error);
    await store.shutdown();
    process.exit(-1);
  });

  process.on('unhandledRejection', async (error) => {
    console.error('Promise rejection not handled properly!');
    console.error(error);
    await store.shutdown();
    process.exit(-1);
  });

  // logger function to add timestamps to logs
  function log(msg) {
    const date = new Date();
    // (all hail the great date method getMonth() that treats the first month as a 0)
    const timestamp = `[${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}]`;
    console.log(`${timestamp} ${msg}`);
  }

  // find all APIs that need to be deleted (names only)
  await store.init();
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - apiExpirationDays);
  const queryData = await store.db.collection('apiConfig').find({
    createdAt: { $lt: cutoffDate },
  });
  const toDelete = await queryData.map(data => data.apiName).toArray();
  log(`The following APIs will be deleted: ${toDelete}`);

  // define async function to run for each API
  const deleteApiArtifacts = async (apiName) => {
    log(`----------- ${apiName} -----------`);
    // drop data and custom route collections
    try {
      await store.db.dropCollection(`api:${apiName}`);
      log('Removed data collection.');
    } catch (_) {
      log('Data collection did not exist (or could not be dropped).');
      await store.init();
    }

    try {
      await store.db.dropCollection(`pre:${apiName}`);
      log('Removed and custom route definitions.');
    } catch (_) {
      log('Custom route collection did not exist (or could not be dropped).');
      await store.init();
    }

    // drop residual id counters
    const idRemoval = await store.db.collection('idStore').deleteMany({
      resource: { $regex: `^${apiName}` },
    });
    log(`${idRemoval.deletedCount} entries from id counter collection removed.`);

    // remove API name from a potential user's connected API list
    const userCleanup = await store.db.collection('users').findOneAndUpdate({
      connectedApis: apiName,
    }, {
      $pull: {
        connectedApis: apiName,
      },
    });
    if (userCleanup.value) {
      log(`Removed entry from user ${userCleanup.value.github.name}'s collection.`);
    } else {
      log('API was not connected to a user.');
    }

    // remove API from central api config collection
    const apiRemoval = await store.db.collection('apiConfig').deleteOne({
      apiName,
    });
    if (apiRemoval.deletedCount > 0) {
      log('Successfully removed API from the database.');
    } else {
      log('WARNING! API was not fully removed from the database (entry in apiConfig not found or deleted).');
    }
  };

  // sequentially run deletion function for all API names
  await toDelete.reduce(async (promise, apiName) => {
    await promise;
    await deleteApiArtifacts(apiName);
  }, Promise.resolve(null));

  store.shutdown();
  process.exit();
}());
